<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>The Common Thread: Dynamic Connections</title>
    <link href="https://fonts.googleapis.com/css2?family=Avenir+Next+LT:wght@300;400;600;800&family=Bebas+Neue&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --agate: #D6883A;
            --aventurine: #3E9B9B;
            --azurite: #842366;
            --bloodstone: #15404F;
            --alexandrite: #4C194C;
            --deep-navy: #050a10;
            --paper: #f4f1ea;
        }

        body {
            font-family: 'Avenir Next LT', sans-serif;
            background-color: var(--deep-navy);
            color: var(--paper);
            margin: 0;
            padding: 0;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.6;
            overflow-x: hidden;
            position: relative; /* Needed for absolute positioning of canvas */
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2; /* Below body::before if it exists, but behind content */
            pointer-events: none; /* Allows clicks to pass through to elements below */
        }

        /* Atmospheric background effect (inherited from prototype_horizon) */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at top left, rgba(214, 136, 58, 0.1) 0%, transparent 40%),
                        radial-gradient(circle at bottom right, rgba(132, 35, 102, 0.1) 0%, transparent 40%);
            z-index: -1;
            animation: atmospheric-glow 15s infinite alternate ease-in-out;
        }

        @keyframes atmospheric-glow {
            0% {
                background-position: 0% 0%, 100% 100%;
            }
            100% {
                background-position: 100% 100%, 0% 0%;
            }
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Bebas Neue', impact, sans-serif;
            color: var(--agate);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        h1 { font-size: 3em; }
        h2 { font-size: 2.5em; }
        h3 { font-size: 2em; }

        .container {
            width: 90%;
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem 0;
            position: relative; /* Ensure content is above canvas */
            z-index: 0;
        }

        /* Header Styling - Changed to absolute so it scrolls away */
        .site-header {
            position: absolute;
            top: 30px;
            left: 40px;
            z-index: 100;
            display: flex;
            align-items: center;
            opacity: 0.9;
            transition: opacity 0.3s;
        }
        .site-header:hover { opacity: 1; }
        
        .logo-svg {
            height: 32px;
            width: auto;
            margin-right: 12px;
            stroke: var(--agate);
            stroke-width: 2;
            fill: none;
        }
        
        .header-title {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--agate);
            font-size: 1.5rem;
            letter-spacing: 2px;
            line-height: 1;
        }

        /* Footer Logo Styling - Outside of card */
        .site-footer {
            margin-top: 4rem;
            margin-bottom: 4rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            opacity: 0.8;
        }
        
        .footer-logo-svg {
            height: 50px;
            width: auto;
            stroke: var(--agate);
            stroke-width: 2;
            fill: none;
        }

        .footer-brand {
            font-family: 'Bebas Neue', sans-serif;
            color: var(--agate);
            font-size: 1.2rem;
            letter-spacing: 2px;
        }

        .footer-link {
            color: var(--paper);
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        .footer-link:hover { opacity: 1; color: var(--agate); }


        .content-block {
            background: rgba(255, 255, 255, 0.05); /* Glassmorphism background */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            padding: 2.5rem;
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .content-block p {
            margin-bottom: 1rem;
        }

        .content-block .subtitle {
            font-family: 'Avenir Next LT', sans-serif;
            text-transform: none;
            letter-spacing: normal;
            font-size: 1.2em;
            color: var(--paper);
            margin-top: -1em;
            margin-bottom: 1.5em;
        }

        .trend-icon {
            font-size: 2.5em;
            margin-bottom: 0.5em;
            color: var(--agate); 
            display: block;
            text-align: center;
        }

        .trend-title {
            text-align: center;
            margin-bottom: 1em;
            color: var(--agate);
        }

        .implication-section {
            margin-top: 2em;
            border-top: 1px dashed rgba(255, 255, 255, 0.1);
            padding-top: 1.5em;
        }

        .implication-section h4 {
            color: var(--theme-color, var(--aventurine)); 
            letter-spacing: 2px;
            font-size: 1.2em;
            margin-bottom: 0.8em;
        }

        .implication-section p {
            color: var(--paper);
        }

        .stat-section {
            margin-top: 1.5em;
            font-style: italic;
            color: rgba(var(--paper), 0.7);
        }

        .stat-section strong {
            color: var(--theme-color, var(--agate));
        }

        .intro-block { border-left: 5px solid var(--agate); }
        .trend-block { border-left: 5px solid var(--theme-color, var(--agate)); }
        .outro-block { border-left: 5px solid var(--agate); }
    </style>
</head>
<body>
    <!-- Absolute Header (Scrolls Away) -->
    <header class="site-header">
        <svg class="logo-svg" viewBox="0 0 45 45">
            <path d="M12.8981 42.9916V2.34497L1.77832 13.4648V31.8718L12.8981 42.9916Z"></path>
            <path d="M31.3051 2.34497L42.4249 13.4648V31.8718L31.3051 42.9916L12.8981 22.6678L31.3051 2.34497Z"></path>
            <path d="M42.4252 13.4648L31.6953 22.6678L42.4252 31.8718"></path>
            <path d="M31.3047 2.34497V42.9916"></path>
            <path d="M1.77832 13.4648L12.7364 22.6508L1.77832 31.8718"></path>
        </svg>
        <span class="header-title">INNOVATE COMMS</span>
    </header>

    <canvas id="threadCanvas"></canvas>
    <div class="container" id="content-container">
        <!-- Content will be injected here by JavaScript -->
    </div>

    <!-- Footer container will be injected here -->

    <script>
        const TELECOMS_CONFIG = {
            branding: {
                companyName: "Innovate Comms",
                website: "https://www.innovatecomms.co.uk/",
                email: "hello@innovatecomms.co.uk"
            },
            intro: {
                title: "5 THINGS SHAPING UK TELECOMS",
                subtitle: "And what it means for your comms",
                p1: "UK telecoms is in the middle of something significant – a period that's reshaping competitive dynamics, investment priorities, and the fundamental question of what telecoms is.",
                p2: "Long promised mergers are completing. AI is changing how we operate. Investments are being redistributed. And 6G needs a different story if it’s going to avoid 5G’s stumbles. These shifts create both urgency and opportunity and how you communicate matters more now than ever."
            },
            outro: {
                title: "The Common Thread",
                p1: "The next phase of UK telecoms will hinge on smart collaborations to create advanced, sustainable networks that are genuinely useful for the UK’s digital ambitions.",
                p2: "Ready to do things differently? Say hello@innovatecomms.co.uk"
            },
            trends: [
                {
                    id: 1,
                    tag: "MARKET",
                    title: "Market Consolidation",
                    desc: "Vodafone and Three are finally one, consuming them in a quagmire of integration. There’s a window of opportunity to communicate with clarity while the biggest player is distracted.",
                    implication: "With a new giant in the market, no one can compete on scale. Where you can compete is innovation, differentiation and focusing on what’s close to the hearts of your customers. Examine your proposition and don’t get bogged down in what worked before – this is a new playing field.",
                    stat: "Scale Shift",
                    statDesc: "Competition moves from scale to innovation.",
                    icon: "fa-handshake",
                    color: "#D6883A" // Agate
                },
                {
                    id: 2,
                    tag: "AI",
                    title: "AI Reality Check",
                    desc: "AI is already in the network and the benefit is real and measurable. But the AI narrative is stuck in either being futuristic or in the technical weeds. There’s an opportunity to tell it properly.",
                    implication: "Communicate what AI actually does in your solution, specifically for a real customer. That’s the story that cuts through. Don’t be afraid to tackle the issues and concerns around it – trust and security are paramount.",
                    stat: "Measurable AI",
                    statDesc: "Trust and security are paramount for national infrastructure.",
                    icon: "fa-brain",
                    color: "#842366", // Azurite
                    powerupIcon: "fa-robot"
                },
                {
                    id: 3,
                    tag: "FIBRE",
                    title: "The Fibre Narrative",
                    desc: "Fibre is winning the infrastructure race but losing the public narrative. Confusion in a crowded market and affordability anxiety is currently winning over the impressive achievement.",
                    implication: "Battle the idea that fibre is a utility by showcasing the innovations it can enable. Shift the conversation from speed and price to impacts for remote business, rural productivity, and economic development.",
                    stat: "Narrative Gap",
                    statDesc: "Move the conversation from price to human impact.",
                    icon: "fa-network-wired",
                    color: "#3E9B9B", // Aventurine
                    powerupIcon: "fa-bolt"
                },
                {
                    id: 4,
                    tag: "SUSTAINABILITY",
                    title: "Sustainability Proof",
                    desc: "Sustainability pledges are no longer enough, proof is needed and the industry is facing a credibility problem. Tangible trials, data and transparency around net-zero is key.",
                    implication: "The era of sustainability-by-announcement is over. Make it tangible for increasingly savvy audiences using data, visualisation, and customer case studies to become a preferred supplier.",
                    stat: "Credibility",
                    statDesc: "Data and transparency are the new net-zero standards.",
                    icon: "fa-leaf",
                    color: "#15404F", // Bloodstone
                    powerupIcon: "fa-leaf"
                },
                {
                    id: 5,
                    tag: "6G",
                    title: "The 6G Evolution",
                    desc: "The global race to 6G is on but commercial reception is cool. 5G overpromised and while research is focused, the comms strategy framing it as 'next gen mobile' is not.",
                    implication: "Against a backdrop of demand-led innovation, your comms needs to support a world where 6G is evolution, not revolution. Lead with business benefits and commercial outcomes.",
                    stat: "Outcome-Led",
                    statDesc: "Maintain UK position through commercial impact, not hype.",
                    icon: "fa-bolt",
                    color: "#4C194C", // Alexandrite
                    powerupIcon: "fa-tower-broadcast"
                }
            ]
        };

        const BRAND_COLORS = {
            1: '#D6883A', // Agate
            2: '#842366', // Azurite
            3: '#3E9B9B', // Aventurine
            4: '#15404F', // Bloodstone
            5: '#4C194C'  // Alexandrite
        };

        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('content-container');
            const canvas = document.getElementById('threadCanvas');
            const ctx = canvas.getContext('2d');
            let animationFrameId = null; 
            let currentScrollY = 0; 
            let activeThreads = []; 
            let footerLogoTop = 0; // Store footer logo position
            let lastWindowWidth = window.innerWidth;

            const getQuadraticBezierPoint = (p0, p1, p2, t) => {
                const mt = 1 - t;
                return {
                    x: mt * mt * p0.x + 2 * mt * t * p1.x + t * t * p2.x,
                    y: mt * mt * p0.y + 2 * mt * t * p1.y + t * t * p2.y
                };
            };

            const generateThreadPath = (originX, endY, startColor, themeId, triggerY) => {
                const guidePoints = [];
                let currentX = originX;
                let currentY = 0; // START AT TOP
                
                const totalHeight = endY; 
                const numSegments = Math.max(5, Math.ceil(totalHeight / 150));
                const segmentHeight = totalHeight / numSegments;
                
                const amplitude = Math.random() * 40 + 10; 
                const frequency = Math.random() * 0.3 + 0.1; 
                
                const screenCenterX = window.innerWidth / 2;
                const totalDrift = (screenCenterX - originX) * 0.6; 
                const driftPerSegment = totalDrift / numSegments;

                guidePoints.push({ x: currentX, y: currentY });

                for (let i = 1; i <= numSegments; i++) {
                    currentY = i * segmentHeight;
                    const progress = i / numSegments;
                    
                    const wave = Math.sin(i * frequency) * amplitude;
                    currentX += driftPerSegment;
                    const wobblyX = currentX + wave;
                    
                    guidePoints.push({ x: wobblyX, y: currentY });
                }

                const path = [];
                if (guidePoints.length > 2) {
                    let p0 = guidePoints[0];
                    for (let i = 0; i < guidePoints.length - 1; i++) {
                        const p1 = guidePoints[i+1]; 
                        const nextNextP = guidePoints[i+2];
                        let p2;
                        if (nextNextP) {
                            p2 = { 
                                x: (p1.x + nextNextP.x) / 2,
                                y: (p1.y + nextNextP.y) / 2
                            };
                        } else {
                            p2 = p1; 
                        }
                        path.push(p0); path.push(p1); path.push(p2);
                        p0 = p2; 
                    }
                }

                return {
                    path: path, 
                    color: startColor,
                    length: path.length / 3, 
                    totalHeight: totalHeight,
                    maxY: endY,
                    themeId: themeId,
                    triggerY: triggerY 
                };
            };

            const drawThreads = () => {
                const width = canvas.width / (window.devicePixelRatio || 1);
                const height = canvas.height / (window.devicePixelRatio || 1);
                
                ctx.clearRect(0, 0, width, height);
                ctx.save();
                ctx.translate(0, -currentScrollY);

                activeThreads.forEach(thread => {
                    if (currentScrollY < thread.triggerY) return; 

                    const growthStart = thread.triggerY;
                    const pixelsScrolledSinceTrigger = currentScrollY - growthStart;
                    const catchUpSpeed = 2.5; 
                    
                    let currentTipY = pixelsScrolledSinceTrigger * catchUpSpeed;
                    const finalDrawY = Math.min(currentTipY, thread.maxY);

                    if (finalDrawY <= 0) return;

                    ctx.beginPath();
                    
                    // Create gradient for fade out
                    if (footerLogoTop > 0) {
                        const fadeStart = footerLogoTop - 200; 
                        const fullGradient = ctx.createLinearGradient(0, 0, 0, footerLogoTop);
                        fullGradient.addColorStop(0, thread.color);
                        
                        const fadeStartPct = Math.max(0, Math.min(1, fadeStart / footerLogoTop));
                        fullGradient.addColorStop(fadeStartPct, thread.color);
                        fullGradient.addColorStop(1, "rgba(0,0,0,0)"); 
                        
                        ctx.strokeStyle = fullGradient;
                    } else {
                        ctx.strokeStyle = thread.color;
                    }

                    ctx.lineWidth = 2; 
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.globalAlpha = 0.9;
                    
                    let pStart = thread.path[0];
                    ctx.moveTo(pStart.x, pStart.y);

                    for (let i = 0; i < thread.length; i++) {
                        const idx = i * 3;
                        const p0 = thread.path[idx];
                        const p1 = thread.path[idx + 1];
                        const p2 = thread.path[idx + 2];

                        if (p2.y <= finalDrawY) {
                            ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
                        } else {
                            const segHeight = p2.y - p0.y;
                            if (segHeight > 0) {
                                const t = Math.max(0, Math.min(1, (finalDrawY - p0.y) / segHeight));
                                const partial = getQuadraticBezierPoint(p0, p1, p2, t);
                                ctx.quadraticCurveTo(p1.x, p1.y, partial.x, partial.y);
                            }
                            break; 
                        }
                    }
                    ctx.stroke();
                });
                
                ctx.restore();
                animationFrameId = null;
            };

            const resizeCanvas = () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const dpr = window.devicePixelRatio || 1;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                ctx.scale(dpr, dpr);
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                
                // Check if width changed significantly to avoid "shuffling" on vertical resize (mobile scroll)
                if (Math.abs(width - lastWindowWidth) > 10 || activeThreads.length === 0) {
                    lastWindowWidth = width;
                    initThreads(); // Full path regeneration
                } else {
                    updateThreadLimits(); // Only update vertical triggers/limits
                }
                
                if (animationFrameId === null) {
                    animationFrameId = requestAnimationFrame(drawThreads);
                }
            };

            const createElement = (tag, className, textContent = '') => {
                const element = document.createElement(tag);
                element.className = className;
                element.textContent = textContent;
                return element;
            };

            // Content Generation
            container.appendChild(createElement('div', 'content-block intro-block')).innerHTML = `
                <h1>${TELECOMS_CONFIG.intro.title}</h1>
                <p class="subtitle">${TELECOMS_CONFIG.intro.subtitle}</p>
                <p>${TELECOMS_CONFIG.intro.p1}</p>
                <p>${TELECOMS_CONFIG.intro.p2}</p>
            `;

            TELECOMS_CONFIG.trends.forEach(trend => {
                const trendBlock = createElement('div', 'content-block trend-block');
                trendBlock.setAttribute('data-color', trend.color);
                trendBlock.setAttribute('data-theme-id', trend.id);
                trendBlock.style.setProperty('--theme-color', trend.color);
                
                trendBlock.innerHTML = `
                    <div class="trend-icon" style="color: var(--theme-color)"><i class="fa-solid ${trend.icon}"></i></div>
                    <h2 class="trend-title" style="color: var(--theme-color)">${trend.title}</h2>
                    <p>${trend.desc}</p>
                    <div class="implication-section">
                        <h4>IMPLICATION:</h4>
                        <p>${trend.implication}</p>
                    </div>
                    <p class="stat-section"><strong>${trend.stat}:</strong> ${trend.statDesc}</p>
                `;
                container.appendChild(trendBlock);
            });

            // Outro Block
            const outroBlock = createElement('div', 'content-block outro-block');
            outroBlock.innerHTML = `
                <h2>${TELECOMS_CONFIG.outro.title}</h2>
                <p>${TELECOMS_CONFIG.outro.p1}</p>
                <p>${TELECOMS_CONFIG.outro.p2}</p>
            `;
            container.appendChild(outroBlock);

            // Separate Footer Logo Container
            const footerContainer = createElement('footer', 'site-footer');
            footerContainer.innerHTML = `
                <svg class="footer-logo-svg" viewBox="0 0 45 45">
                    <path d="M12.8981 42.9916V2.34497L1.77832 13.4648V31.8718L12.8981 42.9916Z"></path>
                    <path d="M31.3051 2.34497L42.4249 13.4648V31.8718L31.3051 42.9916L12.8981 22.6678L31.3051 2.34497Z"></path>
                    <path d="M42.4252 13.4648L31.6953 22.6678L42.4252 31.8718"></path>
                    <path d="M31.3047 2.34497V42.9916"></path>
                    <path d="M1.77832 13.4648L12.7364 22.6508L1.77832 31.8718"></path>
                </svg>
                <div class="footer-brand">INNOVATE COMMS</div>
                <a href="mailto:${TELECOMS_CONFIG.branding.email}" class="footer-link">${TELECOMS_CONFIG.branding.email}</a>
            `;
            document.body.appendChild(footerContainer);


            // --- Thread Initialization ---
            const initThreads = () => {
                const trendBlocks = document.querySelectorAll('.trend-block');
                const footer = document.querySelector('.site-footer');
                const footerRect = footer.getBoundingClientRect();
                
                // Track where the footer starts relative to document
                footerLogoTop = footerRect.top + window.scrollY;
                
                const finalEndY = footerLogoTop; 
                
                activeThreads = [];

                TELECOMS_CONFIG.trends.forEach((trend, index) => {
                    const block = trendBlocks[index];
                    const rect = block.getBoundingClientRect();
                    
                    const triggerY = (rect.top + window.scrollY) - (window.innerHeight * 0.75);
                    
                    const widthPct = 0.8;
                    const startX = (window.innerWidth * (1 - widthPct) / 2) + 
                                   (window.innerWidth * widthPct * (index / 4));
                    
                    activeThreads.push(generateThreadPath(
                        startX,
                        finalEndY, 
                        BRAND_COLORS[trend.id],
                        trend.id,
                        triggerY 
                    ));
                });
                
                if (animationFrameId === null) {
                    animationFrameId = requestAnimationFrame(drawThreads);
                }
            };
            
            // Only updates vertical limits, keeping X paths stable
            const updateThreadLimits = () => {
                const trendBlocks = document.querySelectorAll('.trend-block');
                const footer = document.querySelector('.site-footer');
                const footerRect = footer.getBoundingClientRect();
                
                footerLogoTop = footerRect.top + window.scrollY;
                const finalEndY = footerLogoTop;
                
                activeThreads.forEach((thread, index) => {
                    const block = trendBlocks[index];
                    const rect = block.getBoundingClientRect();
                    const triggerY = (rect.top + window.scrollY) - (window.innerHeight * 0.75);
                    
                    thread.triggerY = triggerY;
                    thread.maxY = finalEndY;
                    
                    // Note: thread.path is NOT updated, so X coordinates remain stable.
                    // However, we should probably update the totalHeight if page height changed drastically.
                    // But re-generating path changes X.
                    // For mobile scroll bar resize, the height change is small enough that scaling the Y might be overkill.
                    // The path is defined by control points. We can't easily stretch it without regen.
                    // But since we are drawing segments based on Y, and capping at maxY...
                    // If page got longer, thread.path might stop short?
                    // generateThreadPath creates path points up to endY.
                    // If endY increases, we need more points.
                    // But usually mobile scroll resize *shrinks* viewport height, not document height.
                    // Document height stays roughly same. So path is valid.
                });
            }

            const updateScrollAndDraw = () => {
                currentScrollY = window.scrollY;
                if (animationFrameId === null) {
                    animationFrameId = requestAnimationFrame(drawThreads);
                }
            };

            window.addEventListener('scroll', updateScrollAndDraw);
            window.addEventListener('resize', resizeCanvas);
            
            setTimeout(() => {
                resizeCanvas(); 
            }, 100);
        });
    </script>
</body>
</html>
