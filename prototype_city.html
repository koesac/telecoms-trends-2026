<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Future of Telecoms: Holo-Table</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; color: #00ffff; }
        
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px;
        }
        
        .header { text-shadow: 0 0 10px #00ffff; }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        
        .controls {
            pointer-events: auto;
            display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 20px;
        }
        
        .btn-layer {
            background: rgba(0, 50, 50, 0.8); border: 1px solid #00ffff; color: #00ffff;
            padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: 0.2s;
            text-transform: uppercase; font-family: inherit; font-size: 0.8rem;
        }
        
        .btn-layer.active { background: #00ffff; color: #000; box-shadow: 0 0 15px #00ffff; }
        
        .info-box {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            width: 250px; background: rgba(0, 20, 20, 0.9); border: 1px solid #00ffff;
            padding: 20px; opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        
        .info-box.visible { opacity: 1; }
        
        /* Mobile adjustment */
        @media (max-width: 600px) {
            .info-box { top: 60px; right: 20px; left: 20px; width: auto; transform: none; }
        }
        
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui">
        <div class="header">
            <h1>City OS v6.0</h1>
            <div style="font-size: 0.8rem; opacity: 0.7;">SMART INFRASTRUCTURE VISUALIZER</div>
        </div>
        
        <div class="info-box" id="info-box">
            <h3 id="info-title">LAYER DATA</h3>
            <p id="info-desc" style="font-size: 0.9rem; line-height: 1.4;">Select a layer to view details.</p>
        </div>

        <div class="controls">
            <button class="btn-layer active" onclick="toggleLayer('buildings')">BUILDINGS</button>
            <button class="btn-layer" onclick="toggleLayer('traffic')">TRAFFIC</button>
            <button class="btn-layer" onclick="toggleLayer('energy')">ENERGY</button>
            <button class="btn-layer" onclick="toggleLayer('data')">DATA</button>
            <a href="index.html" class="btn-layer" style="text-decoration:none; border-color:#fff; color:#fff;">EXIT</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000505, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Grid (Tabletop)
        const gridHelper = new THREE.GridHelper(20, 20, 0x00ffff, 0x003333);
        scene.add(gridHelper);

        // Layers
        const layers = {
            buildings: new THREE.Group(),
            traffic: new THREE.Group(),
            energy: new THREE.Group(),
            data: new THREE.Group()
        };

        Object.values(layers).forEach(g => scene.add(g));

        // Generate Buildings
        const citySize = 10;
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0x00aaaa, wireframe: true, transparent: true, opacity: 0.5 });
        
        for(let i=0; i<50; i++) {
            const h = Math.random() * 3 + 0.5;
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set((Math.random()-0.5)*citySize, h/2, (Math.random()-0.5)*citySize);
            mesh.scale.set(1 + Math.random(), h, 1 + Math.random());
            layers.buildings.add(mesh);
        }

        // Generate Traffic (Moving Particles)
        const trafficGeo = new THREE.BufferGeometry();
        const trafficPos = [];
        for(let i=0; i<200; i++) {
            trafficPos.push((Math.random()-0.5)*citySize, 0.1, (Math.random()-0.5)*citySize);
        }
        trafficGeo.setAttribute('position', new THREE.Float32BufferAttribute(trafficPos, 3));
        const trafficMat = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.15 });
        const trafficParticles = new THREE.Points(trafficGeo, trafficMat);
        layers.traffic.add(trafficParticles);
        layers.traffic.visible = false;

        // Energy (Pylons/Lines)
        const energyGeo = new THREE.CylinderGeometry(0.05, 0.05, 4);
        const energyMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        for(let i=0; i<5; i++) {
            const pylon = new THREE.Mesh(energyGeo, energyMat);
            pylon.position.set((Math.random()-0.5)*8, 2, (Math.random()-0.5)*8);
            layers.energy.add(pylon);
        }
        layers.energy.visible = false;

        // Data (Floating Clouds)
        const dataGeo = new THREE.SphereGeometry(0.1, 8, 8);
        const dataMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const dataCloud = new THREE.InstancedMesh(dataGeo, dataMat, 100);
        const dummy = new THREE.Object3D();
        for(let i=0; i<100; i++) {
            dummy.position.set((Math.random()-0.5)*10, Math.random()*4 + 1, (Math.random()-0.5)*10);
            dummy.updateMatrix();
            dataCloud.setMatrixAt(i, dummy.matrix);
        }
        layers.data.add(dataCloud);
        layers.data.visible = false;

        // Interaction
        window.toggleLayer = (name) => {
            const group = layers[name];
            group.visible = !group.visible;
            
            // Update UI
            const btn = document.querySelector(`.btn-layer[onclick*="${name}"]`);
            btn.classList.toggle('active', group.visible);
            
            // Update Info
            if(group.visible) {
                const info = document.getElementById('info-box');
                const title = document.getElementById('info-title');
                const desc = document.getElementById('info-desc');
                
                info.classList.add('visible');
                title.innerText = name.toUpperCase();
                
                if(name === 'buildings') desc.innerText = "Smart structures with embedded sensors monitoring structural integrity.";
                if(name === 'traffic') desc.innerText = "Autonomous vehicle flow optimization reducing congestion by 40%.";
                if(name === 'energy') desc.innerText = "Smart grid distribution reacting to real-time load demands.";
                if(name === 'data') desc.innerText = "6G holographic data streams permeating the urban environment.";
            }
        };

        // Animation
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            angle += 0.005;
            camera.position.x = Math.sin(angle) * 15;
            camera.position.z = Math.cos(angle) * 15;
            camera.lookAt(0, 0, 0);
            
            // Animate Traffic
            const positions = trafficParticles.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i] += (Math.random()-0.5)*0.1;
                positions[i+2] += (Math.random()-0.5)*0.1;
                // Boundaries
                if(positions[i] > 5) positions[i] = -5;
                if(positions[i] < -5) positions[i] = 5;
                if(positions[i+2] > 5) positions[i+2] = -5;
                if(positions[i+2] < -5) positions[i+2] = 5;
            }
            trafficParticles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
