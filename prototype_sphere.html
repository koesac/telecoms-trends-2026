<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Future of Telecoms: Harmonic Web</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000510; font-family: 'Cinzel', serif; color: #fff; }
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end; padding-bottom: 50px;
        }
        
        h1 { position: absolute; top: 20px; left: 30px; margin: 0; color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        
        .hint {
            background: rgba(0,0,0,0.5); border: 1px solid #00ffff; padding: 10px 20px;
            text-align: center; font-size: 0.9rem; color: #aaa;
        }
        
        .btn-exit {
            position: absolute; top: 20px; right: 30px; pointer-events: auto;
            color: #fff; text-decoration: none; border: 1px solid #fff; padding: 5px 15px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui">
        <h1>Harmonic Web</h1>
        <div class="hint">HOVER to interact • CLICK to pluck • DRAG to rotate</div>
        <a href="index.html" class="btn-exit">EXIT</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.03);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playNote(freq) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.frequency.value = freq;
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }

        // Web Structure
        const nodes = [];
        const lines = [];
        const group = new THREE.Group();
        scene.add(group);

        const nodeGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

        // Create Nodes
        for(let i=0; i<12; i++) {
            const mesh = new THREE.Mesh(nodeGeo, nodeMat);
            const r = 4;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            mesh.position.x = r * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = r * Math.sin(phi) * Math.sin(theta);
            mesh.position.z = r * Math.cos(phi);
            
            mesh.userData = { id: i, freq: 200 + i * 50 };
            group.add(mesh);
            nodes.push(mesh);
        }

        // Create Lines (Strings)
        const lineMat = new THREE.LineBasicMaterial({ color: 0x005555, transparent: true, opacity: 0.3 });
        const activeLineMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8 });

        for(let i=0; i<nodes.length; i++) {
            for(let j=i+1; j<nodes.length; j++) {
                if(nodes[i].position.distanceTo(nodes[j].position) < 5) {
                    const geo = new THREE.BufferGeometry().setFromPoints([nodes[i].position, nodes[j].position]);
                    const line = new THREE.Line(geo, lineMat.clone());
                    line.userData = { p1: nodes[i], p2: nodes[j], plucked: false };
                    group.add(line);
                    lines.push(line);
                }
            }
        }

        // Interaction
        const raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 0.5; // Larger hit area for mobile
        const mouse = new THREE.Vector2();
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Mouse Events
        window.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => isDragging = false);
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if(isDragging) {
                group.rotation.y += e.movementX * 0.005;
                group.rotation.x += e.movementY * 0.005;
            }
        });

        window.addEventListener('click', (e) => checkIntersection(e.clientX, e.clientY));

        // Touch Events
        window.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        window.addEventListener('touchend', (e) => {
            isDragging = false;
            // Simple tap detection (if moved less than threshold, treat as click)
            // Ideally we track distance, but for now let's assume if not moving much it's a tap
            // Or just check intersection on end
            const touch = e.changedTouches[0];
            checkIntersection(touch.clientX, touch.clientY);
        });

        window.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const deltaMove = {
                x: touch.clientX - previousMousePosition.x,
                y: touch.clientY - previousMousePosition.y
            };

            if(isDragging) {
                group.rotation.y += deltaMove.x * 0.005;
                group.rotation.x += deltaMove.y * 0.005;
            }
            previousMousePosition = { x: touch.clientX, y: touch.clientY };
        });

        function checkIntersection(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(lines);
            
            if(intersects.length > 0) {
                pluckString(intersects[0].object);
            }
        }

        function pluckString(line) {
            if(line.userData.plucked) return;
            line.userData.plucked = true;
            
            // Visual Pluck
            line.material.color.setHex(0xff00ff);
            line.material.opacity = 1;
            
            // Audio Pluck (Harmonic of length)
            const dist = line.userData.p1.position.distanceTo(line.userData.p2.position);
            playNote(800 / dist); // Shorter = higher pitch
            
            // Animation
            gsap.to(line.material, { opacity: 0.3, duration: 0.5, onComplete: () => {
                line.material.color.setHex(0x005555);
                line.userData.plucked = false;
            }});
        }

        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += 0.001;
            
            // Hover logic
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(lines);
            
            if(intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                intersects[0].object.material.opacity = 0.8;
            } else {
                document.body.style.cursor = 'default';
                lines.forEach(l => {
                    if(!l.userData.plucked) l.material.opacity = 0.3;
                });
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
